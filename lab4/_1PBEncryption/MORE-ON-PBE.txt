
PBE (Password Based Encryption) Scehes and Constructions
and Protection of Hashed Passwords

SRSC 23/24, Lab Discussion Note
===============================

In general / Summary:

In summary, the use of a password-based encryption technique uses
"passwords" (expected strong passwords) and salt values (eventually together with other elements, such as challenge/response NONCEs or sequence counters) to generate keys that will be used to protect data that must be protected.

The way the keys are generated by the implicit key-generation function in a PBE scheme is a core security condition for the use of the PBE scheme in its construction.

Different approaches for he key-generation process:
- Use of secure hash functions to produce hash values (with the security properties offered by the used hash function), and a derivation process to obtai the necessary keys. It is easy and it is fast, being secure, depending on the secure hash function used (avoiding what we consider today as weak or semi-weak has functions, such as MD5, SHA-1, etc).
- Sometimes the used hash function must be selected to be compliant with
possible regulatory frameworks and rational references on the use of
cryptographic foundations and cimpliant mechanisms.

- In authentiction protocols, the way the client must use different elements (beyond the original clear text passwords) to transform the password to obtain the hashed password, can be based on one-time challenge values for salts, counters, sequence numbers or even timestamps, challenged by the authentication server hat can control and can pre-compute the transformed password that must be exibhited by a client, in teh enx authentication challenge.


- It is also relevant to say that in many cases, the password involved is not necessarily only one "single" password, but a set of "secrets" representing multiple authentication factors that must be computed by the client for an authentication protocol. In this strategy we can use multiple independent devices or multiple authentication elements based on physical biometric evideces (fingerprints, iris, hand-recognition, voice-rcognition, face-recognition) or elemengs provided from external, independent and isolated devices (such as cryptographci elements computed from smartcards, cryptographic dongles or other cryptographic devices. In this case, the user is not authenticated by an authentication service because she/he knows a password as "something she/he knows" (the password factor) but because she/he proved to have "something" (resuting from a speciifc device as "something she/he have factor") or because she/he proved to be someone physicaly (the biometric factors). It is also possible to use
non-physical "biometric" factors to identity users, such as: the rithm of
writing in a keyboard or a drawed pattern in a pad, for example.

SPECIALIZED HASH-FUNCTIONS for STORAGE PASSWORD-PROTECTION
==========================================================

For the specific case of password protection in storage (example
storage in authentication ssl or application ssl) involves
 the use of "so called" specialized
 password-based cryptographic hash functions.

See https://en.wikipedia.org/wiki/Cryptographic_hash_function for a discussion about this type of mechanisms - Pssword Verification Section:

In general password verification commonly relies on cryptographic hashes.
Storing all user passwords as cleartext can result in a massive security breach if the password file is compromised by an adversary that can gain access to password-config files, databases, etc.
To reduce this danger the idea is to store the hash digest of each password (or components of different hash elements (computed from different secure hash functions) of the password for hightest security.

The idea is simple: to authenticate a user, the password asked to the user (in a client side) is presented to a authentiction server hashed in compliance of the storage rules in the server side, to be compared with the stored hash transformation.
A password reset method is required immediatly after the password hashing is performed (not being persistently stored even in computer memory in the client side)

However, use of standard cryptographic hash functions, such as the usual hash algorithms and series (SHA2, SHA3 etc), can be insufficient to be safe (or particularly not suited for password-based authentication purposes) for password storage models using hash-transformations of the password.

These algorithms are designed to be computed quickly, so if the hashed values are compromised, it is possible to try guessed passwords at high rates. Of course this depend of each specific hash function, but even for the more secure hash functions today, this can be an issue (remember for example the power for
hashing inputs, in very fast and specific processors (ex., ASIC processors,
large clusters of powefull concurrent GPUs, etc).
For example, ASIC machines w/ specialized Hardware for Terahashes/second or some common graphics processing units can try billions of possible passwords each second. Password hash functions that perform key stretching, habe been
proposed in the research and standardization efforts. PBKDF2, scrypt or Argon2 are today commonly used as appropriate cryptographic constructions to deal with the problem of password-secrity.

Commonly PBKDF2, scrypt or Argon2 use repeated invocations of cryptographic
hash transformations to increase the time (and in some cases computer memory) required) to perform brute force attacks on stored password hash digests.

Together with the password hash, it is also required the use of a large random, non-secret salt, which can be stored with the password hash transformation.
The salt is hashed with the password, altering the password hash mapping for each password, thereby making it infeasible for an adversary to store tables of pr-computed hash values to which the password hash digest can be compared or to test a large number of purloined hash values in parallel.

